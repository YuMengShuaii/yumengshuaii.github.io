<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android继承友盟推送]]></title>
      <url>%2Fyumengshuaii.github.io%2F2017%2F03%2F30%2F5%2F</url>
      <content type="text"><![CDATA[引言友盟+发布的sdk总体来说质量都挺好，以社会化分享来说，易于集成，代码可读性高，文档条理清晰，本文详细介绍关于友盟推Android端集成。 上友盟官网申请友盟账号，下来友盟U-Push Android版SDK，并且申请APP，得到AppKey，Umeng Message Secre，App Master Secret（这些步骤就不详细描述了，傻瓜式操作）。友盟官网 进入集成阶段，解压下载好的SDK压缩包，在需要集成推送功能的项目中导入PushSdk这个module，导入流程：菜单栏选择File&gt;new&gt;importModule,然后选择PushSdk。 导入完成后，在Priject窗口右击主项目，单击Open Module Settings ，选择dependeneies,点击+号，选择module dependeney，然后选择自己需要依赖的module。 依赖完成后，进行代码配置阶段：首先在AndroidXml配置文件中，Applcation标签下，加入如下metadata12android:name=&quot;UMENG_APPKEY&quot;android:value=&quot;xxxxxxxxxxxxxxxx&quot;&gt;&lt;/meta-data&gt; ``` 以上参数，就是第一步申请的来的相关参数，注意，申请APP的时候包名一定要正确，否则会导致集成失败。 5. 自定义Application，并且在application的onCreate方法中，进行初始化pushSdk的相关操作，代码如下： //获取Push服务单例对象 PushAgent mPushAgent = PushAgent.getInstance(this); //注册推送服务，每次调用register方法都会回调该接口 mPushAgent.register(new IUmengRegisterCallback() { @Override public void onSuccess(String deviceToken) { //注册成功会返回device token } @Override public void onFailure(String s, String s1) { } }); PushAgent.getInstance(getApplicationContext()).onAppStart(); ``` 至此集成友盟推送消息完毕，请到友盟后台管理，推送消息测试是否集成成功，如集成失败，请检查本文步骤，查看官网文档，看看是否遗漏相关操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LoadRunner常用技巧]]></title>
      <url>%2Fyumengshuaii.github.io%2F2017%2F03%2F27%2F1%2F</url>
      <content type="text"><![CDATA[脚本在录制脚本中，采用Loadrunner而自动录制脚本难免会录入一切不必要的数据，如果直接采用这个样的脚本进行压测的话，测试结果会十分不准确，因为在LoadRunner的录制过程中，包括Cookies，不必要的Url都会被录制下来，所以我们需要去删减脚本，增强脚本。 脚本越小越好主要包括：删除cookies、删除关键字EXTRARS后面的url、删除不必要的url、删除一切带有敏感标记的内容（比如：不想压测到实际生产线上时，则需要删除www.*.com的所有相关内容） 脚本增强脚本录制完成之后，通过脚本回放可以关联一些动态的参数。在脚本中找到动态参数，右键Replace with parameter（替换为动态参数），根据弹框出现的相应步骤添加动态参数的数据。 自定义参数： “Select next row ”选项中有以下几种选择：多个VU如何取值 Sequential：按照顺序一行行的读取。每一个虚拟用户都会按照相同的顺序读取 Random：在每次循环里随机的读取一个，但是在循环中一直保持不变 Unique ：每个VU取唯一的值。注意：使用该类型必须注意数据表有足够多的数。比如Controller中设定20 个虚拟用户进行5 次循环，那么编号为1 的虚拟用户取前5个数，编号为2 的虚拟用户取6-10的数，依次类推，这样数据表中至少要有100个数据，否则Controller 运行过程中会返回一个错误。 事务在压力测试中，对于性能的衡量，恒大一本分都是根据事务处理的TPS来衡量，所以在事务的设置中，我们要尽量的合理安排。事务要尽可能的只保留核心逻辑。 迭代与并发迭代；在运行时设置中打开step，在step中设置具体的step。并发要在Controller中设置要同时并发多少虚拟用户，可以根据自己的需求，去设置相应的压测方案！ 错误扫雷这里记录几个常遇到的错误解决办法，下载超时，连接超时，发送数据超时，发生这几个错误时，一般做这样的处理，就可以解决：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LoadRunner设置集结点的方法及原理]]></title>
      <url>%2Fyumengshuaii.github.io%2F2017%2F03%2F27%2F2%2F</url>
      <content type="text"><![CDATA[集结点的作用一般是在测试并发时，线程与进程也跟人一样，有强有弱，有的占用资源多，有的占用资源少，所以这种情况测试并发会很不准确，所以就引入了集结点这个概念，集结点就是，如果当前用户指定参与集结点的Vuser都到达了用户指定集结点的位置，那么会同时释放所有到达集结点的Vuser，同时执行之后的测试流程，集结点这个概念，在并发测试中扮演的就是一个减小并发误差的角色。 设置集结点的方法一般分为脚本设置，控制器中设置 脚本添加集结点（Rendezvous方法） lr_rendezvous(&quot;集合点&quot;) //添加集合点 一般情况加插入集结点时，如果脚本中包含事务，那么设置集结点的位置一般在事务之外。 控制中设置集合点 1.在控制器界面中（Controller）打开菜单栏，选择 Scenario -&gt; Rendezvous 打开集合点的设置页面。2.这时可以看到，Pollcy按钮，在这里可以设置集合点策略，可以看到在界面右侧，有对应的Vusers列表，我们可以在有需求的时候，选中某个Vuser点击DisableVuser，可以使该Vuser忽略该集合点设置的集合！3.设置集合策略，在点击Pollcy按钮后会弹框提示用户选择相应的策略：第一个策略表示，当到达集合点的Vuser总数占全部Vuser对应百分比的虚拟用户到达集合时，释放虚拟用户继续运行测试流程;第二个策略表示，当到达集合点的Vuser占运行时全部Vuser的用户到达集结时，释放虚拟用户继续执行测试流程;第三个策略表示，当到达集合点的Vuser总是达到用户指定的Vuser总数时，释放虚拟用户继续执行测试流程。 最后贴上完整脚本 Action() { int nHttpRetCode; //设置集合点 lr_rendezvous(&quot;login_point&quot;); //默认长度256 web_set_max_html_param_len(&quot;262144&quot;); web_reg_save_param(&quot;ResponseBody&quot;, &quot;LB=&quot;, &quot;RB=&quot;, &quot;Search=Body&quot;, LAST); web_save_header(RESPONSE,&quot;ResponseHeader&quot;); //开启事务 lr_start_transaction(&quot;Communicate&quot;); web_custom_request(&quot;saveUser&quot;, &quot;URL=http://www.javamall.com.cn/xxxx/xxx/xxx/xxx/xxx?username=food&amp;password=111111&quot;, &quot;Method=GET&quot;, &quot;Resource=0&quot;, &quot;Referer=&quot;, &quot;Mode=HTTP&quot;, &quot;EncType=text/html;charset=UTF-8&quot;, &quot;Body=&quot;, LAST); lr_convert_string_encoding(lr_eval_string(&quot;{ResponseBody}&quot;),&quot;utf-8&quot;,NULL,&quot;ResponseBody&quot;); lr_output_message(&quot;# xxxx\n %s&quot;, lr_eval_string(&quot;{ResponseHeader}&quot;)); lr_output_message(&quot;# xxxx\n %s&quot;, lr_eval_string(&quot;{ResponseBody}&quot;)); //结束事务 lr_end_transaction(&quot;Communicate&quot;, LR_PASS); nHttpRetCode = web_get_int_property(HTTP_INFO_RETURN_CODE); if(nHttpRetCode == 200) { lr_output_message(&quot;---------------Success!------------&quot;); } else { lr_output_message(&quot;----------------Failed!------------&quot;); } return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LoadRunner压测Get方法]]></title>
      <url>%2Fyumengshuaii.github.io%2F2017%2F03%2F27%2F3%2F</url>
      <content type="text"><![CDATA[首先LoadRunner本身具有很多方法均可测试接口，今天我们使用web_custom_request方法进行Get接口测试。 int nHttpRetCode;//设置http请求code web_set_max_html_param_len(&quot;262144&quot;); // 默认最大长度为256 web_reg_save_param(&quot;ResponseBody&quot;,&quot;LB=&quot;,&quot;RB=&quot;,&quot;Search=Body&quot;, LAST);//设置ResponseBody web_save_header(RESPONSE,&quot;ResponseHeader&quot;);//添加header 如有需要可以开启事务 lr_start_transaction(&quot;Communicate&quot;);//开启事务，名为Communicate。 lr_end_transaction(&quot;Communicate&quot;, LR_PASS); //结束事务 调用request方法 web_custom_request(&quot;getname&quot;, &quot;URL=http://www.javamall.com.cn/xxx/xx/xx/xx/xx?username=xx&amp;password=xxx&quot;, &quot;Method=GET&quot;, &quot;Resource=0&quot;, &quot;Referer=&quot;, &quot;Mode=HTTP&quot;, &quot;EncType=text/html;charset=UTF-8&quot;, &quot;Body=&quot;, LAST); 对返回的Json数据进行转码 //转码 lr_convert_string_encoding(lr_eval_string(&quot;{ResponseBody}&quot;),&quot;utf-8&quot;,NULL,&quot;ResponseBody&quot;); //打印返回数据 lr_output_message(&quot;# 响应头信息：\n %s&quot;,lr_eval_string(&quot;{ResponseHeader}&quot;)); lr_output_message(&quot;# 响应内容体：\n %s&quot;,lr_eval_string(&quot;{ResponseBody}&quot;)); 获取Http请求码，并且判断是否成功！ //获取请求码 nHttpRetCode = web_get_int_property(HTTP_INFO_RETURN_CODE); //判断是否请求成功!(当请求码为200时，请求成功！) if(nHttpRetCode == 200) { lr_output_message(&quot;-------------Success!------------&quot;); } else { lr_output_message(&quot;----------------Failed!------------&quot;); } 完整代码 Action() { int nHttpRetCode; web_set_max_html_param_len(&quot;262144&quot;); // 默认最大长度为256 web_reg_save_param(&quot;ResponseBody&quot;, &quot;LB=&quot;, &quot;RB=&quot;, &quot;Search=Body&quot;, LAST); web_save_header(RESPONSE,&quot;ResponseHeader&quot;); lr_start_transaction(&quot;Communicate&quot;); web_custom_request(&quot;getname&quot;, &quot;URL=http://www.javamall.com.cn/xxx/xx/xx/xx/xxx?username=xxx&amp;password=xxx&quot;, &quot;Method=GET&quot;, &quot;Resource=0&quot;, &quot;Referer=&quot;, &quot;Mode=HTTP&quot;, &quot;EncType=text/html;charset=UTF-8&quot;, &quot;Body=&quot;, LAST); //打印返回信息 lr_convert_string_encoding(lr_eval_string(&quot;{ResponseBody}&quot;),&quot;utf-8&quot;,NULL,&quot;ResponseBody&quot;); lr_output_message(&quot;# 响应头信息：\n %s&quot;, lr_eval_string(&quot;{ResponseHeader}&quot;)); lr_output_message(&quot;# 响应内容体：\n %s&quot;, lr_eval_string(&quot;{ResponseBody}&quot;)); lr_end_transaction(&quot;Communicate&quot;, LR_PASS); nHttpRetCode = web_get_int_property(HTTP_INFO_RETURN_CODE); if(nHttpRetCode == 200) { lr_output_message(&quot;---------------Success!------------&quot;); } else { lr_output_message(&quot;----------------Failed!------------&quot;); } return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebView加载本地无Css的Html出现图片不匹配]]></title>
      <url>%2Fyumengshuaii.github.io%2F2017%2F03%2F27%2F4%2F</url>
      <content type="text"><![CDATA[引言 在Android开发的过程中,有事会遇到这样一种需求，尤其是在图文混排的情况下，有些人会采用直接使用html标签来实现效果，但是，在图片自适应的处理上总是不尽人意，本文针对这种情况下的图片处理做了优化！ ####WebView图片过大是因为，本地Html中没有CSS文件对其进行大小限制，我们通过嵌入Html标签来解决这个问题 设置Html开始与结尾 12private String start=&quot;&lt;html&gt;&quot;;private String end = &quot;&lt;/body&gt;&lt;/html&gt;&quot;; 设置整个页面的自适应宽度，拼接为Html标签 123456789101112131415161718 String header =&quot;&lt;head&gt;&lt;style&gt;img&#123;width:&quot;+(ScreenUtils.px2dip(getBaseContext(),ScreenUtils.getScreenWidthPX(getBaseContext()))-10)+&quot;px !important;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&quot;; //这两个方法是用来获取屏幕的宽度px并转换为dp ScreenUtils.px2dip(getBaseContext(),ScreenUtils.getScreenWidthPX(getBaseContext())); /** * 获取屏幕宽度 */ public static int getScreenWidthPX(Context context) &#123; return context.getResources().getDisplayMetrics().widthPixels;&#125;/** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */public static int px2dip(Context context, float pxValue) &#123; final float scale =context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; 3.拼接成HTML并加载到webView 1blog.loadDataWithBaseURL(&quot;&quot;,start+header+data.get(0).getContent()+end, &quot;text/html&quot;, &quot;utf-8&quot;,&quot;&quot;); 4.到此成功适配宽度]]></content>
    </entry>

    
  
  
</search>
